(load "actors.lisp")

(defun make-drop (cust) `("drop" ,cust))
(defun make-pick (cust) `("pick" ,cust))
(defun pick? (x) (equal (first x) "pick"))
(defun drop? (x) (equal (first x) "drop"))
(defun get-phil (m) (second m))
(defun eat (n) (sleep n))
(defun think (n) (sleep n))

(defactor phil (name l r (sticks 0)) (m)
  (if (zerop sticks)
      (progn
	(format t "~s: Got one~%" name)
	(incf sticks) next)
      (progn 
	(format t "~s: Got both~%" name)
	;; Critical section
	(format t "~s: Eating ...~%" name)
	(eat 3)
	(send l (make-drop self)) (send r (make-drop self))
	(format t "~s: Thinking~%" name)
	(think 2)
	(send l (make-pick self)) (send r (make-pick self))
	(setf sticks 0) next)))

;; Forks need to carry a state!
;; Rivedere perch√® non mi sembra il comportamento corretto
(defactor fork ((h nil) (w nil)) (m)
  (if (pick? m)
      (if (null h)
	  (progn (send (get-phil m) nil) 
		 (setf h (get-phil m) w nil)
		 next)
	  (progn (setf w (get-phil m))
		 next)))
  (if (drop? m)
      (if (null w)
	  (progn (setf w nil h nil)
		 next)
	  (progn (send w nil)
		 (setf h w w nil))))
  next)

(let* ((f1 (fork))
       (f2 (fork))
       (f3 (fork))
       (p1 (phil :name 'Platone :l f1 :r f2))
       (p2 (phil :name 'Aristotele :l f2 :r f3))
       (p3 (phil :name 'Socrate :l f1 :r f3)))
  (send p1 (make-pick f1))
  (send p1 (make-pick f2))
  (send p2 (make-pick f2))
  (send p2 (make-pick f3))
  (send p3 (make-pick f3))
  (send p3 (make-pick f1))
  ;; Go on for 15 sec, then stop everything
  (sleep 15)
  (dolist (x (list p1 p2 p3 f1 f2 f3))
    (stop-actor x))
  (format t "~%15 sec elapsed, done.~%"))
